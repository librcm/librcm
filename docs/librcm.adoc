= librcm -- reusable C modules
Frank Braun <https://frankbraun.org>
2020-08-18
:doctype: book
:reproducible:
:source-highlighter: rouge
:toc: left
:icons: font

This document describes how to write _reusable C modules_ and documents
`librcm`.

ifdef::backend-html5[]
Download as
https://raw.githubusercontent.com/librcm/librcm/master/docs/librcm.pdf[PDF].
endif::[]
ifndef::backend-html5[]
Check https://librcm.org for updates.
endif::[]
Source code on https://github.com/librcm/librcm[GitHub].

== Introduction

The C programming language was first introduced in 1972
and first standardized in 1989 as ANSI C (called C89).
The most important revision of ANSI C in regards to this document is C99.
We ignore all later revisions.

=== The importance of C today

According to the
https://www.tiobe.com/tiobe-index/[TIOBE Index for August 2020]
C is the most popular programming language in the world.

Many operating systems, programming languages,
and widely used libraries are written in C.

High-quality examples:

- The https://www.openbsd.org/[OpenBSD] operating system.
- The https://www.lua.org/[Lua] programming language.
- The https://www.sqlite.org/[SQLite] database engine.

Many higher-level programming programming languages allow to interface with the
C https://en.wikipedia.org/wiki/Application_binary_interface[ABI].

Several new programming languages have the explicit goal to produce libraries
compatible with the C ABI, for example https://ziglang.org/[Zig] and
https://www.rust-lang.org/[Rust].
Others, like https://golang.org/[Go], are criticized for not conforming to the
C ABI.
Conforming to the C ABI is mutually exclusive with garbage collection.

=== The importance of C in the future

Given the importance of C today, it's high performance, it's high portability
(if written correctly), and the rise of
low-performance https://en.wikipedia.org/wiki/Internet_of_things[IoT] devices,
C is likely to stay for many decades.

This means that *well written* C can be used and reused for a very long time.
However, C suffers from a lot of poor quality code.
The C ecosystem also lacks a repository of  *easily reusable* C libraries,
especially ones that can be embedded in other libraries,
can be used in embedded devices, and are highly portable.

The problem of poor quality code is being addressed by restrictive coding
standards and static analysis tools.

Reusable C libraries, however, are still a major problem.
This is mostly due to the fact that the C programming language is so low-level
and flexible that it neither defines a standard way on _how_ to write libraries,
nor does it have a standardized way to handle errors, manage memory,
and deal with dependencies.

Having standardized ways to do things greatly helps to reduce cognitive overhead
thereby and raises program quality and programmer productivity.

This is arguable a big reason that Go became so successful.
The language itself is not extremely powerful, but making
https://golang.org/ref/spec#Package_clause[package names] part of the language
specification and having widely shared opinions in the Go community what
comprises idiomatic code makes Go highly reusable and reduces the cognitive
burden when reading and editing code written by others.

In this document we describe a method on how to write highly quality,
future-proof C code, giving rationales for decisions made.
The power of this approach mainly comes from the *simplicity* that comes from
standardizing on the _only true-way of doing things_ (TM).
It forces the programmer in standardized way of writing C code with less
decisions to be made along the way, freeing up mental capacity for writing the
_actual_ code.

But it comes at the cost that even less C code is reusable, because it doesn't
conform to the future-proof C method. However, as more and more C code becomes
a future-proof *reusable C module* this is less and less of a problem.

== Resusable C modules

=== What does module mean?

A C module is a single C header file which defines and implements an API
that can be used by _consumers_ of the module. The module should
_consume_ as little other modules and header files as possible, to keep
the dependency graph small.

=== What does reusable mean?

Reusable means that such a module should be useful on as many platforms
as possible. Supported platforms include:

- All major POSIX systems: Linux, Mac OS, OpenBSD, and FreeBSD.
- Both major mobile platforms: Android and iOS.
- Embedded systems (like Arduino/AVR microcontrollers).
- 32-bit and 64-bit systems.
- Little-endian and big-endian systems.
- All major compilers: GCC, Clang, MinGW, and Visual Studio.
- All major processor architectures: x86, ARM, and PowerPC.

== Goals

- Modules must not leak symbols into the global name space.
- Modules must be compilable as `static` in an amalgamation file, to
  make them reusable in libraries without any symbol leakage.
- Modules must minimize cognitive overhead. Standardize everything.
- Modules should avoid dynamic memory allocation wherever possible.

See also the
https://github.com/nothings/stb/blob/master/docs/stb_howto.txt[STB how-to].


== Error handling

TODO:

- error codes
- error messages
- error flow
- exceptions


== Memory managment

TODO

== How to write a module

A reusable C module `mod` consists of four components:

1. The header file: `rcm_mod.h`
2. The implementation C file: `rcm_mod.c`
3. The unit test file: `rcm_mod_test.c`
4. The module documentation (generated): `rcm_mod.adoc`

Only the header and the C files are really necessary to reuse the module.
The online documentation for a module is linked from the header file.

We write the documentation in a separate file for the following reasons:

- It gives us the design capabilities of a lightweight markdown language.
- Generated documentation is often of poor quality, because it is written as an
  afterthought. Writing the documentation separately, in the API design stage,
  makes it better.

=== How to write the header file

[source,c]
----
/* SPDX-License-Identifier: Unlicense OR MIT */ <1>

#ifndef RCM_MOD_H <2>
#define RCM_MOD_H

/* Documentation: https://librcm.org/#rcm_mod.h */ <3>

#ifndef RCM_API
#define RCM_API extern <4>
#endif

RCM_API void rcm_mod_foo(void); <5>

RCM_API int rcm_mod_bar(void);

#endif <6>
----
<1> License identifier
<2> https://en.wikipedia.org/wiki/Include_guard[Include guard]
<3> Link to online documentation
<4> Define `RCM_API`. Allows to compile all module functions as `static`
<5> Function definition(s)
<6> End of include guard


== Rules

- Write portable ANSI C89.
- `#include <stdbool.h>` is OK.
- Modules are single header files.
- Public domain for new code (use the [Unlicense]).
- Permissive license (BSD, MIT, or ISC) for modified third party code.
- No GPL.
- Format the code with `clang-format` (standardized `.clang-format`
  file).
- Write unit tests for the code with the
  https://github.com/silentbicycle/greatest[greatest] testing library.

=== Allowed defines

The number of defines used in reusable C modules must be kept to the
absolute minimum! Otherwise `#ifdef`-hell ensues.

List of allowed `#ifdef`-statements:

- `__ANDROID__`: Android.
- `__APPLE__`: Apple platform (MacOS _and_ iOS).
- `__linux__`: Linux (also defined on Android).
- `__FreeBSD__`: FreeBSD.
- `__OpenBSD__`: OpenBSD.
- `_MSC_VER`: The Visual Studio compiler is used. Defined as an
  integer literal that encodes the major and minor number elements of
  the compiler's version number.
- `NDEBUG`: combined with `#ifndef` to disable debugging code.
- `TARGET_OS_IOS`: Is `== 0` for Mac OS and `> 0` for iOS (on Apple
  platform).
- `_WIN32`: Windows (usually with `#ifndef` to implement POSIX first).

=== Coding style

- Error buffer: `char err[ERRBUF_SIZE]` (module `rcm_errbuf.h`)
- Return variables: `int ret`

=== Example module

TODO: `rcm_mod.h` example module.

== How to test

TODO:

- valgrind, clang, greatest
- assertions
- allowed types
- licensensing

=== Use ANSI C89

Stick to C89 with the following exceptions from C99:

- `#include <stdbool.h>` is allowed.

==== Rationale

Visual Studio has poor support for C99.

=== `goto` is not allowed

== `librcm` module dependencies

[graphviz,module_deps]
....
include::module_deps.dot[]
....

== `librcm` module APIs

include::rcm_base64.adoc[]
include::rcm_base64buf.adoc[]
include::rcm_errbuf.adoc[]
include::rcm_mem.adoc[]
include::rcm_mod.adoc[]
include::rcm_pid.adoc[]
include::rcm_rfc3339.adoc[]

== Deliverables

- user guide: How to write future-proof C. With coding rules and
  rationales.
- reference: What APIs are offered?
- tutorials: How to write library module. How to use library.
